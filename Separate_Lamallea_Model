Spectrum MyMicrofacetReflection::f(const Vector3f &wo, const Vector3f &wi) const { ///butterfly
   
    Spectrum specular (0.f);
    float cosThetaO = AbsCosTheta(wo), cosThetaI = AbsCosTheta(wi);
    float v=  cosThetaO + cosThetaI;
    
    float sinThetaO = SinTheta(wo), sinThetaI = SinTheta(wi);
    float u= sinThetaO + sinThetaI;
    
    
    Vector3f wh = wi + wo;
    // Handle degenerate cases for microfacet reflection
    if (cosThetaI == 0 || cosThetaO == 0) return Spectrum(0.);
    if (sinThetaI == 0 || sinThetaO == 0) return Spectrum(0.);
    if (wh.x == 0 && wh.y == 0 && wh.z == 0) return Spectrum(0.);
    wh = Normalize(wh);
    // For the Fresnel call, make sure that wh is in the same hemisphere
    // as the surface normal, so that TIR is handled correctly.
    Spectrum F = fresnel->Evaluate(Dot(wi, Faceforward(wh, Vector3f(0,0,1))));
    
    //torrance sparrow page 553
    float N= 6, d=0.15, M=8, a=0.055, lambdaR= 600, lambdaG= 550, lambdaB= 460;
    float PiSquared= Pi * Pi; 
    
    float  Separate_Lamellae_Model_R =  ( N / (2 * PiSquared)) * ( std::pow(std::sin((Pi * d * v * M)/lambdaR ),2) / std::pow(std::sin((Pi * d * v)/lambdaR), 2)) * ((std::pow(((Pi*a*u)/lambdaR), 2))/(std::pow( (u /lambdaR ), 2))) * std::pow( cosThetaI , 2) ;
    
    float  Separate_Lamellae_Model_G =  ( N / (2 * PiSquared)) * ( std::pow(std::sin((Pi * d * v * M)/lambdaG ),2) / std::pow(std::sin((Pi * d * v)/lambdaG), 2)) * ((std::pow(((Pi*a*u)/lambdaG), 2))/(std::pow( (u /lambdaG ), 2))) * std::pow( cosThetaI , 2) ;
       
    float  Separate_Lamellae_Model_B =  ( N / (2 * PiSquared)) * ( std::pow(std::sin((Pi * d * v * M)/lambdaB ),2) / std::pow(std::sin((Pi * d * v)/lambdaB), 2)) * ((std::pow(((Pi*a*u)/lambdaB), 2))/(std::pow( (u /lambdaB), 2))) * std::pow( cosThetaI , 2) ;
    
        
    float f3[3];
    f3[0]= Separate_Lamellae_Model_R;
    f3[1]= Separate_Lamellae_Model_G; 
    f3[2]= Separate_Lamellae_Model_B;
    
   //std::cout<<Separate_Lamellae_Model_R<<std::endl;
   //std::cout<<Separate_Lamellae_Model_G<<std::endl;
   //std::cout<<Separate_Lamellae_Model_B<<std::endl;
    
    
    specular = (Spectrum) RGBSpectrum::FromRGB (f3) * R;
    return specular;
    
           
}
